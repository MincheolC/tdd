# 3부. 객체 지향 스타일 설계

## 6장. 객체 지향 스타일
### 6.1 유지 보수성을 고려한 설계
- 코드 규모가 커질수록 유지보수가 쉬워지려면, 기능->객체->패키지->프로그램->시스템 순으로 구조화
- 구조화를 위한 두 가지 휴리스틱
  #### 1 관심사의 분리
  - 동작 방식 변경을 위해 최대한 적은 양의 코드를 수정하는 것이 좋다
  - 같은 이유로 변경해야 할 코드는 한데 모은다. (메세지를 푸는 코드와 해석하는 코드를 분리)
  #### 2 더 높은 수준의 추상화
  - 더 높은 수준의 추상화(복잡한 개념에서 기능을 간추려 냄)를 활용해 복잡성을 피함
  - 변수, 제어를 조작하기 보단 유용한 기능 컴포넌트를 조합하여 작성
  - 포트와 어댑터 아키텍처
    - 포트 : 애플리케이션 용어로 외부 객체를 표현하는 인터페이스 작성(기술적 개념 제외)
	- 어댑터 : 애플리케이션의 핵심부와 각 기술 도메인 사이에 브리지 코드 작성
![Alt text](https://github.com/betterdevstomorrow/tdd/blob/master/chapter03/image/pig_6_1.PNG)

  * 캡슐화와 정보 은닉
    - 캡슐화 : 객체의 행위가 해당 객체의 API를 통해서만 좌우될 수 있음을 보장(관련 없는 컴포넌트 간 의존성 제거)
	- 정보 은닉 : 객체가 해당 객체의 기능을 구현하는 방법을 API단으로 숨김
	
### 6.2 내부 대 이웃
- 시스템 구성 시 해당 객체가 명확한 API와 함께 응집력 있는 추상화를 제공하도록 해야함
- 내부에 접근하는 것을 API를 통해 캡슐화, 나머지 시스템으로부터 세부 사항 은닉
- 이웃(peer) : 한 객체와 의사소통하는 객체

```java
(EditSaveCustomizer) master.getModelisable()
	.getDockablePanel()
	.getCustomizer()
	.getSaveItem.setEnabled(Boolean.FALSE.booleanValue());
```
- 캡슐화, 은닉 정도는 어떤 객체를 얼마나 쉽게 쓸 수 있는지에 영향을 줘 시스템 내부 품질에 기여
- 낮은 추상화는 열차 전복 코드처럼 유지 보수 비용이 증가(master 변경을 위해 모든 중간 관계를 변경해야 함)	

### 6.3 단일 책임 원칙
- 모든 객체는 반드시 단 한 가지 명확히 규정된 책임을 지녀야 함
- 객체의 역할을 설명할 때 접속사 없이 설명할 수 있어야 함(접속사가 들어가면 각 절마다 객체가 됨)
- 여러 객체를 조합해 새로운 추상화를 만들 때도 적용(전체는 부분의 합보다 단순해야 함)

### 6.4 객체 이웃의 유형
- 객체가 지닐 수 있는 관계 3가지
  #### 1 의존성
  - 한 객체가 자신의 역할을 수행할 수 있게 이웃하는 객체에게 요구하는 서비스
  - 이웃의 서비스 없이는 기능을 수행하지 못함
  #### 2 알림
  - 한 객체의 최근 활동을 지속적으로 파악하는 이웃
  - 상태가 바뀌거나 중요한 활동을 수행할 때마다 특정 이웃에게 알림
  - 비유도형 미사일과 같이 어떤 이웃이 listener로 등록되어 있는지 신경쓰지 않음
  - 객체를 서로 분리해줌(인터페이스가가 모든 등록된 리스너에게 알리지만 리스너가 무엇을 했는지 알지 못하고, 리스너도 인터페이스로부터 호출될 것은 알지만 인터페이스가 어떻게 이벤트를 전달할지는 알지 못함)
  #### 3 조정
  - 객체 행위를 더 넓은 시스템의 요건에 맞게 조정하는 이웃
  - 해당 객체를 대신해 의사 결정을 내리는 정책 객체, 복합체인 경우 해당 객체의 컴포넌트를 포함
    - JTable의 TableCellRenderer에서 색상 값으로 RGB를 사용한다면, 렌더러(renderer)를 변경함으로써ㅓ HSB(색조,채도,명도) 값으로 표현될 수 있음

- 유효한 객체를 만들기 위해 노력하지만, 의존성의 경우 요구된 서비스를 이용할 수 있기 전까지는 객체를 생성하더라도 NullPointerException을 발생시킬 것이다.(강제 할당 방법이 있긴 함)
- 조정의 경우 공통 값으로, 알림의 경우 널 객체나 빈 컬렉션으로 초기화 하고 메서드를 추가해 호출하는 쪽에서 값을 변경하도록 할 수 있음.

### 6.5 전체는 부분의 합보다 단순해야 한다
- 객체를 조합해 새 타입을 만들 때 새 타입이 그것을 구성하는 모든 구성 요소를 합한 것보다 단순한 행위를 보여주게 하고 싶음
- 복합 객체의 API는 반드시 구성 요소의 존재와 구성 요소 간 상호 작용을 감추고 더 단순한 추상화를 보여주어야 함
- 시계에서 시간을 표시하는 두세 개의 침, 태엽 감는 꼭지 등이 있지만 모두 한데 조립되어 있음
- 금액 값을 수정하기 위해 금액 수정, 통화 수정 컴포넌트로 구성될 수 있다. 컴포넌트의 API에서 두 값을 모두 처리하지 못한다면, 다음과 같이 컴포넌트를 직접 제어할 수밖에 없을 것이다.
```java
moneyEditor.getAmountField().setText(String.valueOf(money.amount());
moneyEditor.getCurrencyField().setText(String.valueOf(money.currencyCode());
```
- 다음과 같이 설정자 메서드로 대체하여 추상화 할 수 있다.
```java
moneyEditor.setAmountField(money.amount());
moneyEditor.setCurrencyField(money.currencyCode());
```
- 내부 구조를 제거하고 다음과 같이 나타낼 수 있다.
```java
moneyEditor.setValue(money);
```
### 6.6 콘텍스트 독립성
- 한 객체가 정보를 감췄는지 판단하는 것이 6.5의 내용이었다면, 콘텍스트 독립성은 한 객체가 정보를 너무 많이 감췄거나 잘못된 정보를 감췄는지 판단하는데 유용함
- 각 객체가 해당 객체를 실행하는 시스템에 관해 아무것도 알지 못함
- 어떤 객체가 실행되고 있는, 규모가 더 큰 환경에 대해 해당 객체가 알아야 할 사항을 전부 전달해야 함(생성자에 전달(영구적) 또는 메서드에 전달(일시적))
- 객체의 관계를 명시적으로 만들고 객체 자체와는 별도로 정의되게 만듦
- 다양한 콘텍스트에 적용할 수 있는 응집력 있는 객체를 만들 수 있고, 구성 방법 재설정을 통해 변경 가능한 시스템이 될 수 있음	

### 6.7 올바른 정보 감추기
- 설계 시 아래와 같은 두 개념의 차이점을 인식해야 함
  - 캐시에 대한 자료 구조를 CachingAuctionLoader 클래스에 캡슐화한다(감춘다).
  - 애플리케이션 로그 파일의 이름을 PricingPolicy 클래스에 캡슐화한다(감춘다).
- 로그 파일의 이름을 PricingPolicy에 감추는 업무는 없다(필요하지 않다). 로그 파일의 이름은 외부 환경 설정 수준에 포함되어야 한다.
  
  
## 7장 객체 지향 설계의 달성
### 7.1 테스트를 먼저 작성하는 것이 설계에 어떻게 도움이 되는가
- 호출자는 객체가 무슨 일을 하고 무엇에 의존하는지 알고 싶을 뿐, 객체가 어떻게 동작하는지는 알고 싶어 하지 않음
- 객체가 해당 객체를 둘러싼 더 큰 환경과 조화되는 응집력 있는 단위를 나타내기를 바람
- 위와 같은 목적에 도움이 되는 TDD의 세 가지 측면
  #### 1 '어떻게'를 고려하기 전에 달성하는 바가 '무엇인지'를 기술해야 함
  - 대상 객체에 대한 추상화를 올바른 수준으로 유지
  - 단위 테스트의 의도가 불분명하다면 개념이 뒤죽박죽이 될 것임
  - 객체 외부에서 무엇을 볼 수 있는지 결정해야 하므로 정보 은닉에도 도움이 됨
  #### 2 단위 테스트의 범위를 제한해야 함
  - 단위 테스트가 수십줄이 되어 테스트의 요점이 묻히는 경우가 발생
  - 컴포넌트를 최대한 쪼개어 단순한 테스트로 작성
  #### 3 해당 객체의 의존성을 전달하기 위해 의존성이 어디에 있는지 알아야 함
  - 의존성을 정리하여 콘텍스트 단위 테스트를 위한 객체들의 독립성을 높여야 함

### 7.2 분류보다 의사소통
- 인터페이스는 두 컴포넌트가 잘 맞는지를 기술하는 반면, 프로토콜은 두 컴포넌트가 함께 동작하는지를 기술
- 잘 설계된 클래스 구조를 달성하는 것보다 객체의 의사소통 패턴이 더 중요
- 목 객체를 활용한 TDD는 개발 과정에서 통신 프로토콜을 발견하는 수단이자 코드의 설명으로 작용

```java
@Test public void
notifiesAuctionClosedWhenCloseMessageReceived() {
	Message message = new Message();
	message.setBody("SOLVersion: 1.1; Event: CLOSE;");
	
	context.checking(new Expectations() {{
		oneOf(listener).auctionClosed();
	}});
	
	translator.processMessage(UNUSED_CHAT, message);
}
```
- listener 인터페이스에 다른 메서드도 있지만, 위 테스트는 해당 프로토콜에서 auctionClosed() 메서드가 딱 한 번만 호출되어야 함을 말해준다.
- 목 객체는 객체 내부에 존재하는 것이 아니라 객체와 동위 요소(해당 객체의 의존성, 알림, 조정을 대상으로)로 만들어야 함
- 한 객체의 인접 요소를 강조하는 테스트는 그것들이 이웃 요소인지, 대상 객체의 내부를 구성해야 하는지 파악하는 데 기여
- 불분명한 테스트는 구현 세부 사항을 너무 드러냄

### 7.3 값 타입
- 값은 불변이라서 좀 더 단순하고 유의미한 식별자가 없으며, 객체에는 상태가 있어서 식별자가 있고 서로 관계를 맺는다.
- 시스템에 String을 사용하기보다 Item 타입을 만들면 메서드 호출없이 변경과관련된 코드를 찾아낼 수 있다.
- 구체적인 타입은 혼동의 위험을 줄임(화성 기후 탐사선의 미터, 피트의 경우와 같이)
- 개념을 표현하는 타입을 만들어두면 행위를 추가하기에 적절함(코드 구석구석에 흩어놓는 대신 좀 더 객체지향적)
- 값 타입을 위한 세 가지 기법
  #### 1 분해(breaking out)
  - 객체의 코드가 복잡해지고 있다면 응집력 있는 행위의 단위로 분해
  - 메시지 문자열을 구문 분석, 구문 분석 결과를 해석하는 단위로 분해
  #### 2 파생(budding off)
  - 새로운 도매인 개념을 표시하고 싶을 때 필드 하나만 있거나 필드가 아무것도 없는 위치지정자 타입을 도입
  - 코드 규모가 커짐에 따라 필드와 메서드를 추가해 새로운 타입의 세부 사항을 채우고 각 타입을 통해 추상화 수준을 높임
  #### 3 포장(bundling up)
  - 어떤 값들이 함께 사용된다는 사실을 알게될 경우 함께 취급되는 공용 필드가 포함된 타입을 새로 만듦
  - 새 타입으로 행위를 옮길 수 있는데 이는 인터페이스 너머로 새 타입에 포함된 필드를 감추어 '전체는 부분의 합보다 단순해야 한다'를 만족함

### 7.4 객체는 어디에서 오는가?
- 객체 타입을 발견하는 범주는 대개 다들 비슷하다.
#### 7.4.1 분해: 큰 객체를 협력 객체의 그룹으로 나누기
- 작성한 코드가 복잡해질 경우 응집력 있는 기능 단위를 좀 더 작은 협력 객체로 만드는 작업을 할 수 있다.
- 손쉽게 테스트할 수 없을 정도로 크거나 테스트 실패 이유를 해석하기 어려우면 해당 객체를 분해하여 단위 테스트를 수행
#### 7.4.2 파생: 객체가 필요로 하는 신규 서비스 정의와 해당 서비스를 제공하기 위한 새 객체 추가
- 어떤 객체를 구현할 때 그 객체가 또 다른 객체에서 제공받아야 할 서비스를 필요로 한다는 사실을 발견
- 새로운 서비스에 이름을 부여하고 클라이언트 객체와 새로운 서비스 간 관계를 명확히 하고자 해당 서비스를 클라이언트 객체의 단위 테스트 바깥에서 목 객체로 만들어 제공
- 서비스를 제공하는 객체 작성(객체가 필요로하는 서비스가 뭔지 파악)?? => 서비스를 제공하는 또 다른 객체 작성(기존 객체가 필요로 하는 서비스가 무엇인지 파악)
- 기존 객체, 또는 자체적으로 만든 API나 서드파티 API와 연결하기 전까지 협력 객체의 관계로 구성된 흐름을 가짐
#### 7.4.3 포장: 관련 객체를 포함 객체로 감추기
- 함께 동작하는 관련 객체의 집합이 있을 경우 그것들을 하나로 포함하는 객체로 포장할 수 있다.(좀 더 높은 추상화 수준을 가짐)
- 암시적인 개념을 구체적으로 만드는 과정의 장점
  - 도메인을 좀 더 잘 이해하는 데 보탬이 되는 이름을 부여해야 함
  - 개념의 경계를 확인할 수 있으므로 의존성의 범위를 좀 더 명확하게 한정할 수 있다.
  - 단위 테스트를 좀 더 정확하게 수행할 수 있다.(새로운 구성 객체를 직접 테스트, 뽑아낸 객체의 코드에 대한 테스트를 위해 목 구현체 사용 가능)
### 7.5 인터페이스로 관계를 식별하라
- 인터페이스를 사용해 객체가 수행할 수 있는 역할에 이름을 부여하고 객체가 받아들일 메시지를 기술
- 인터페이스를 되도록 한정된 범위로 사용하려 한다. 인터페이스에 선언되는 메서드 수가 적을수록 해당 메서들르 호출하는 객체의 역할이 명확해진다.
- 클라이언트에 코드에서 인터페이스를 쓰면 불필요한 정보가 새는 현상을 방지하여 객체 간의 암시적인 결합이 최소화되고 변경하기 쉬운 코드가 된다.
### 7.6 인터페이스도 리팩터링하라
- 공통적인 역할을 뽑아내면 '착탈 가능한' 컴포넌트가 많아져서 설계가 좀 더 높은 수준의 추상화로 작업할 수 있다.
- 개념을 이해하는 데 걸리는 시간이 더 적어질 수 있다.
- 구현하는 클래스의 구조가 불분명하다는 사실을 알게된다면 인터페이스가 너무 장황해서 쪼개야한다는 힌트가 된다.
### 7.7 객체를 구성해 시스템의 행위를 기술하라
- 단위 수준의 TDD는 시스템을 값 타입과 느슨하게 결합된 계산 관련 객체로 분해하는 데 길잡이 노릇을 함
- jMock에서는 테스트를 위해 예상 호출을 기술한 내용을 Mockery 콘텍스트 객체 내에서 조합 -> 테스트가 실행되는 동안 Mockery는 목 객체의 대상 객체를 상대로 발생한 호출을 Expectation에 전달 -> 각 Expectation에서 호출 일치 여부 검사 -> 일치하면 테스트 성공, 불일치하면 테스트 실패
- 비교적 적은 코드로 유연한 애플리케이션 구조가 만들어지며, 여러 관련 시나리오를 지원해야 할 때 적절한 방법
- 각 시나리오에 대해 구축할 다양한 컴포넌트 조합은 애플리케이션의 어떤 부분에 들어갈 하위 시스템에 해당함
- 설계 확장이 쉽다.
![Alt text](https://github.com/betterdevstomorrow/tdd/blob/master/chapter03/image/pig_7_1.PNG)

- example.doSomething() 메서드가 String 타입의 인자로 정확히 한 번 호출되는지 확인하는 테스트 코드는 다음과 같다.
```java
InvocationExpectation expectation = new InvocationExpectation();
expectation.setParametersMatcher(new AllParametersMatcher(Arrays.asList(new IsInstanceOf(String.class))));
expectation.setCardinality(new Cardinality(1, 1));
expectation.setMethodMatcher(new Method(NameMatcher("doSomething"));
expectation.setObjectMatcher(new IsSame<Example>(example));

context.addExpectation(expectation);
```

### 7.8 고수준 프로그래밍을 위한 대비
- 우리는 흔히 객체와 그것들의 관계에 관한 정보를 키워드, 설정자, 표기법 등에 묻어버린다(숨긴다?).
- 객체를 할당하고 연결하는 것이 의도를 표현하지 않기 때문에 시스템의 행위를 이해하는 데 도움이 되지 못한다. 
- 코드를 두 가지 계층으로 구성
  - 객체의 그래프에 해당하는 구현 계층 : 객체가 이벤트에 어떻게 반응하는가?
  - 구현계층의 객체를 만들어내는 선언적 계층 : 각 부분의 용도를 기술(하려는 일이 무엇인가?), 좀 더 융통성이 있어 메서드 호출 연쇄(열차 전복), 정적 메서드 사용 가능
  - 이전 절의 예제를 다음과 같이 재작성 할 수 있다.
```java
context.checking(new Expectations() {{
	oneOf(example).doSomething(with(any(String.class)));
}});
```
  - Expectations 객체는 예상 구문을 생성하는 빌더로써 예상 구문과 매처의 조합을 생성해 그것을 Mockery로 불러들이는 메서드가 정의되어 있음
  - 선언적 계층은 거듭되는 '무차별적인' 리팩터링에서 나타난다. 객체를 직접 구성하고 중복을 제거, 도우미 메서드를 추가해 문법적 잡음을 추려내고 예상 구문을 추가, 어떤 영역이 명확해질 때까지 구조를 추가하거나 옮기는 과정에서 발생
![Alt text](https://github.com/betterdevstomorrow/tdd/blob/master/chapter03/image/pig_7_2.PNG)

- 목표는 더 적은 코드로 더 많은 일을 해내는 것(객체가 더 작은 해우이의 단위를 형성하는 수준에 이르도록 구현)

### 7.9 그럼 클래스는?
- 보통 클래스보다 인터페이스를 강조하는데, 다른 객체에서 보는 것은 결국 인터페이스이기 때문이다. 객체의 타입은 해당 객체가 수행하는 역할로 규정된다.
- 클래스는 구현 세부 사항으로 타입을 구현하는 한 방식이지 타입 자체는 아니다.
- 공통적인 행위를 추려냄으로써 클래스 계층 구조를 파악하며 가능하다면 위임(클래스에 포함시킴?)으로 리팩터링 하는 방식을 선호 -> 위임으로 코드를 더 유연하고 이해하기 쉽게 만들 수 있음
- 값 타입은 동위 요소가 없어서 위임을 사용할 가능성이 낮다.