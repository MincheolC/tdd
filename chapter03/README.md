# 3부. 객체 지향 스타일 설계

## 6장. 객체 지향 스타일
### 6.1 유지 보수성을 고려한 설계
- 코드 규모가 커질수록 유지보수가 쉬워지려면, 기능->객체->패키지->프로그램->시스템 순으로 구조화
- 구조화를 위한 두 가지 휴리스틱
  #### 1 관심사의 분리
  - 동작 방식 변경을 위해 최대한 적은 양의 코드를 수정하는 것이 좋다
  - 같은 이유로 변경해야 할 코드는 한데 모은다. (메세지를 푸는 코드와 해석하는 코드를 분리)
  #### 2 더 높은 수준의 추상화
  - 더 높은 수준의 추상화(복잡한 개념에서 기능을 간추려 냄)를 활용해 복잡성을 피함
  - 변수, 제어를 조작하기 보단 유용한 기능 컴포넌트를 조합하여 작성
  - 포트와 어댑터 아키텍처
    - 포트 : 애플리케이션 용어로 외부 객체를 표현하는 인터페이스 작성(기술적 개념 제외)
	- 어댑터 : 애플리케이션의 핵심부와 각 기술 도메인 사이에 브리지 코드 작성
![Alt text](https://github.com/betterdevstomorrow/tdd/blob/master/chapter03/image/pig_6_1.PNG)
  * 캡슐화와 정보 은닉
    - 캡슐화 : 객체의 행위가 해당 객체의 API를 통해서만 좌우될 수 있음을 보장(관련 없는 컴포넌트 간 의존성 제거)
	- 정보 은닉 : 객체가 해당 객체의 기능을 구현하는 방법을 API단으로 숨김
	
### 6.2 내부 대 이웃
- 시스템 구성 시 해당 객체가 명확한 API와 함께 응집력 있는 추상화를 제공하도록 해야함
- 내부에 접근하는 것을 API를 통해 캡슐화, 나머지 시스템으로부터 세부 사항 은닉
- 이웃(peer) : 한 객체와 의사소통하는 객체

```java
(EditSaveCustomizer) master.getModelisable()
	.getDockablePanel()
	.getCustomizer()
	.getSaveItem.setEnabled(Boolean.FALSE.booleanValue());
```
- 캡슐화, 은닉 정도는 어떤 객체를 얼마나 쉽게 쓸 수 있는지에 영향을 줘 시스템 내부 품질에 기여
- 낮은 추상화는 열차 전복 코드처럼 유지 보수 비용이 증가(master 변경을 위해 모든 중간 관계를 변경해야 함)	

### 6.3 단일 책임 원칙
- 모든 객체는 반드시 단 한 가지 명확히 규정된 책임을 지녀야 함
- 객체의 역할을 설명할 때 접속사 없이 설명할 수 있어야 함(접속사가 들어가면 각 절마다 객체가 됨)
- 여러 객체를 조합해 새로운 추상화를 만들 때도 적용(전체는 부분의 합보다 단순해야 함)

### 6.4 객체 이웃의 유형
- 객체가 지닐 수 있는 관계 3가지
  #### 1 의존성
  - 한 객체가 자신의 역할을 수행할 수 있게 이웃하는 객체에게 요구하는 서비스
  - 이웃의 서비스 없이는 기능을 수행하지 못함
  #### 2 알림
  - 한 객체의 최근 활동을 지속적으로 파악하는 이웃
  - 상태가 바뀌거나 중요한 활동을 수행할 때마다 특정 이웃에게 알림
  - 비유도형 미사일과 같이 어떤 이웃이 listener로 등록되어 있는지 신경쓰지 않음
  - 객체를 서로 분리해줌(인터페이스가가 모든 등록된 리스너에게 알리지만 리스너가 무엇을 했는지 알지 못하고, 리스너도 인터페이스로부터 호출될 것은 알지만 인터페이스가 어떻게 이벤트를 전달할지는 알지 못함)
  #### 3 조정
  - 객체 행위를 더 넓은 시스템의 요건에 맞게 조정하는 이웃
  - 해당 객체를 대신해 의사 결정을 내리는 정책 객체, 복합체인 경우 해당 객체의 컴포넌트를 포함
    - JTable의 TableCellRenderer에서 색상 값으로 RGB를 사용한다면, 렌더러(renderer)를 변경함으로써ㅓ HSB(색조,채도,명도) 값으로 표현될 수 있음

- 유효한 객체를 만들기 위해 노력하지만, 의존성의 경우 요구된 서비스를 이용할 수 있기 전까지는 객체를 생성하더라도 NullPointerException을 발생시킬 것이다.(강제 할당 방법이 있긴 함)
- 조정의 경우 공통 값으로, 알림의 경우 널 객체나 빈 컬렉션으로 초기화 하고 메서드를 추가해 호출하는 쪽에서 값을 변경하도록 할 수 있음.

### 6.5 전체는 부분의 합보다 단순해야 한다
- 객체를 조합해 새 타입을 만들 때 새 타입이 그것을 구성하는 모든 구성 요소를 합한 것보다 단순한 행위를 보여주게 하고 싶음
- 복합 객체의 API는 반드시 구성 요소의 존재와 구성 요소 간 상호 작용을 감추고 더 단순한 추상화를 보여주어야 함
- 시계에서 시간을 표시하는 두세 개의 침, 태엽 감는 꼭지 등이 있지만 모두 한데 조립되어 있음
- 금액 값을 수정하기 위해 금액 수정, 통화 수정 컴포넌트로 구성될 수 있다. 컴포넌트의 API에서 두 값을 모두 처리하지 못한다면, 다음과 같이 컴포넌트를 직접 제어할 수밖에 없을 것이다.
```java
moneyEditor.getAmountField().setText(String.valueOf(money.amount());
moneyEditor.getCurrencyField().setText(String.valueOf(money.currencyCode());
```
- 다음과 같이 설정자 메서드로 대체하여 추상화 할 수 있다.
```java
moneyEditor.setAmountField(money.amount());
moneyEditor.setCurrencyField(money.currencyCode());
```
- 내부 구조를 제거하고 다음과 같이 나타낼 수 있다.
```java
moneyEditor.setValue(money);
```
### 6.6 콘텍스트 독립성
- 한 객체가 정보를 감췄는지 판단하는 것이 6.5의 내용이었다면, 콘텍스트 독립성은 한 객체가 정보를 너무 많이 감췄거나 잘못된 정보를 감췄는지 판단하는데 유용함
- 각 객체가 해당 객체를 실행하는 시스템에 관해 아무것도 알지 못함
- 어떤 객체가 실행되고 있는, 규모가 더 큰 환경에 대해 해당 객체가 알아야 할 사항을 전부 전달해야 함(생성자에 전달(영구적) 또는 메서드에 전달(일시적))
- 객체의 관계를 명시적으로 만들고 객체 자체와는 별도로 정의되게 만듦
- 다양한 콘텍스트에 적용할 수 있는 응집력 있는 객체를 만들 수 있고, 구성 방법 재설정을 통해 변경 가능한 시스템이 될 수 있음	

### 6.7 올바른 정보 감추기
- 설계 시 아래와 같은 두 개념의 차이점을 인식해야 함
  - 캐시에 대한 자료 구조를 CachingAuctionLoader 클래스에 캡슐화한다(감춘다).
  - 애플리케이션 로그 파일의 이름을 PricingPolicy 클래스에 캡슐화한다(감춘다).
- 로그 파일의 이름을 PricingPolicy에 감추는 업무는 없다(필요하지 않다). 로그 파일의 이름은 외부 환경 설정 수준에 포함되어야 한다.
  
  
## 7장 객체 지향 설계의 달성
### 7.1 테스트를 먼저 작성하는 것이 설계에 어떻게 도움이 되는가
- 호출자는 객체가 무슨 일을 하고 무엇에 의존하는지 알고 싶을 뿐, 객체가 어떻게 동작하는지는 알고 싶어 하지 않음
- 객체가 해당 객체를 둘러싼 더 큰 환경과 조화되는 응집력 있는 단위를 나타내기를 바람
- 위와 같은 목적에 도움이 되는 TDD의 세 가지 측면
  #### 1 '어떻게'를 고려하기 전에 달성하는 바가 '무엇인지'를 기술해야 함
  - 대상 객체에 대한 추상화를 올바른 수준으로 유지
  - 단위 테스트의 의도가 불분명하다면 개념이 뒤죽박죽이 될 것임
  - 객체 외부에서 무엇을 볼 수 있는지 결정해야 하므로 정보 은닉에도 도움이 됨
  #### 2 단위 테스트의 범위를 제한해야 함
  - 단위 테스트가 수십줄이 되어 테스트의 요점이 묻히는 경우가 발생
  - 컴포넌트를 최대한 쪼개어 단순한 테스트로 작성
  #### 3 해당 객체의 의존성을 전달하기 위해 의존성이 어디에 있는지 알아야 함
  - 의존성을 정리하여 콘텍스트 단위 테스트를 위한 객체들의 독립성을 높여야 함

### 7.2 분류보다 의사소통
- 인터페이스는 두 컴포넌트가 잘 맞는지를 기술하는 반면, 프로토콜은 두 컴포넌트가 함께 동작하는지를 기술
- 잘 설계된 클래스 구조를 달성하는 것보다 객체의 의사소통 패턴이 더 중요
- 목 객체를 활용한 TDD는 개발 과정에서 통신 프로토콜을 발견하는 수단이자 코드의 설명으로 작용

```java
@Test public void
notifiesAuctionClosedWhenCloseMessageReceived() {
	Message message = new Message();
	message.setBody("SOLVersion: 1.1; Event: CLOSE;");
	
	context.checking(new Expectations() {{
		oneOf(listener).auctionClosed();
	}});
	
	translator.processMessage(UNUSED_CHAT, message);
}
```
- listener 인터페이스에 다른 메서드도 있지만, 위 테스트는 해당 프로토콜에서 auctionClosed() 메서드가 딱 한 번만 호출되어야 함을 말해준다.
- 목 객체는 객체 내부에 존재하는 것이 아니라 객체와 동위 요소(해당 객체의 의존성, 알림, 조정을 대상으로)로 만들어야 함
- 한 객체의 인접 요소를 강조하는 테스트는 그것들이 이웃 요소인지, 대상 객체의 내부를 구성해야 하는지 파악하는 데 기여
- 불분명한 테스트는 구현 세부 사항을 너무 드러냄

### 7.3 값 타입
- 값은 불변이라서 좀 더 단순하고 유의미한 식별자가 없으며, 객체에는 상태가 있어서 식별자가 있고 서로 관계를 맺는다.
- 시스템에 String을 사용하기보다 Item 타입을 만들면 메서드 호출없이 변경과관련된 코드를 찾아낼 수 있다.
- 구체적인 타입은 혼동의 위험을 줄임(화성 기후 탐사선의 미터, 피트의 경우와 같이)
- 개념을 표현하는 타입을 만들어두면 행위를 추가하기에 적절함(코드 구석구석에 흩어놓는 대신 좀 더 객체지향적)
- 값 타입을 위한 세 가지 기법
  #### 1 분해(breaking out)
  - 객체의 코드가 복잡해지고 있다면 응집력 있는 행위의 단위로 분해
  - 메시지 문자열을 구문 분석, 구문 분석 결과를 해석하는 단위로 분해
  #### 2 파생(budding off)
  - 새로운 도매인 개념을 표시하고 싶을 때 필드 하나만 있거나 필드가 아무것도 없는 위치지정자 타입을 도입
  - 코드 규모가 커짐에 따라 필드와 메서드를 추가해 새로운 타입의 세부 사항을 채우고 각 타입을 통해 추상화 수준을 높임
  #### 3 포장(bundling up)
  - 어떤 값들이 함께 사용된다는 사실을 알게될 경우 함께 취급되는 공용 필드가 포함된 타입을 새로 만듦
  - 새 타입으로 행위를 옮길 수 있는데 이는 인터페이스 너머로 새 타입에 포함된 필드를 감추어 '전체는 부분의 합보다 단순해야 한다'를 만족함

### 7.4 객체는 어디에서 오는가?
- 객체 타입을 발견하는 범주는 대개 다들 비슷하다.
#### 7.4.1 분해: 큰 객체를 협력 객체의 그룹으로 나누기
- 작성한 코드가 복잡해질 경우 응집력 있는 기능 단위를 좀 더 작은 협력 객체로 만드는 작업을 할 수 있다.
- 손쉽게 테스트할 수 없을 정도로 크거나 테스트 실패 이유를 해석하기 어려우면 해당 객체를 분해하여 단위 테스트를 수행
#### 7.4.2 파생: 객체가 필요로 하는 신규 서비스 정의와 해당 서비스를 제공하기 위한 새 객체 추가
- 어떤 객체를 구현할 때 그 객체가 또 다른 객체에서 제공받아야 할 서비스를 필요로 한다는 사실을 발견
- 새로운 서비스에 이름을 부여하고 클라이언트 객체와 새로운 서비스 간 관계를 명확히 하고자 해당 서비스를 클라이언트 객체의 단위 테스트 바깥에서 목 객체로 만들어 제공
- 서비스를 제공하는 객체 작성(객체가 필요로하는 서비스가 뭔지 파악)?? => 서비스를 제공하는 또 다른 객체 작성(기존 객체가 필요로 하는 서비스가 무엇인지 파악)
- 기존 객체, 또는 자체적으로 만든 API나 서드파티 API와 연결하기 전까지 협력 객체의 관계로 구성된 흐름을 가짐
#### 7.4.3 포장: 관련 객체를 포함 객체로 감추기
- 함께 동작하는 관련 객체의 집합이 있을 경우 그것들을 하나로 포함하는 객체로 포장할 수 있다.(좀 더 높은 추상화 수준을 가짐)
- 암시적인 개념을 구체적으로 만드는 과정의 장점
  - 도메인을 좀 더 잘 이해하는 데 보탬이 되는 이름을 부여해야 함
  - 개념의 경계를 확인할 수 있으므로 의존성의 범위를 좀 더 명확하게 한정할 수 있다.
  - 단위 테스트를 좀 더 정확하게 수행할 수 있다.(새로운 구성 객체를 직접 테스트, 뽑아낸 객체의 코드에 대한 테스트를 위해 목 구현체 사용 가능)
### 7.5 인터페이스로 관계를 식별하라
- 인터페이스를 사용해 객체가 수행할 수 있는 역할에 이름을 부여하고 객체가 받아들일 메시지를 기술
- 인터페이스를 되도록 한정된 범위로 사용하려 한다. 인터페이스에 선언되는 메서드 수가 적을수록 해당 메서들르 호출하는 객체의 역할이 명확해진다.
- 클라이언트에 코드에서 인터페이스를 쓰면 불필요한 정보가 새는 현상을 방지하여 객체 간의 암시적인 결합이 최소화되고 변경하기 쉬운 코드가 된다.
### 7.6 인터페이스도 리팩터링하라
- 공통적인 역할을 뽑아내면 '착탈 가능한' 컴포넌트가 많아져서 설계가 좀 더 높은 수준의 추상화로 작업할 수 있다.
- 개념을 이해하는 데 걸리는 시간이 더 적어질 수 있다.
- 구현하는 클래스의 구조가 불분명하다는 사실을 알게된다면 인터페이스가 너무 장황해서 쪼개야한다는 힌트가 된다.
### 7.7 객체를 구성해 시스템의 행위를 기술하라
- 단위 수준의 TDD는 시스템을 값 타입과 느슨하게 결합된 계산 관련 객체로 분해하는 데 길잡이 노릇을 함
- jMock에서는 테스트를 위해 예상 호출을 기술한 내용을 Mockery 콘텍스트 객체 내에서 조합 -> 테스트가 실행되는 동안 Mockery는 목 객체의 대상 객체를 상대로 발생한 호출을 Expectation에 전달 -> 각 Expectation에서 호출 일치 여부 검사 -> 일치하면 테스트 성공, 불일치하면 테스트 실패
- 비교적 적은 코드로 유연한 애플리케이션 구조가 만들어지며, 여러 관련 시나리오를 지원해야 할 때 적절한 방법
- 각 시나리오에 대해 구축할 다양한 컴포넌트 조합은 애플리케이션의 어떤 부분에 들어갈 하위 시스템에 해당함
- 설계 확장이 쉽다.
![Alt text](https://github.com/betterdevstomorrow/tdd/blob/master/chapter03/image/pig_7_1.PNG)
- example.doSomething() 메서드가 String 타입의 인자로 정확히 한 번 호출되는지 확인하는 테스트 코드는 다음과 같다.
```java
InvocationExpectation expectation = new InvocationExpectation();
expectation.setParametersMatcher(new AllParametersMatcher(Arrays.asList(new IsInstanceOf(String.class))));
expectation.setCardinality(new Cardinality(1, 1));
expectation.setMethodMatcher(new Method(NameMatcher("doSomething"));
expectation.setObjectMatcher(new IsSame<Example>(example));

context.addExpectation(expectation);
```

### 7.8 고수준 프로그래밍을 위한 대비
- 우리는 흔히 객체와 그것들의 관계에 관한 정보를 키워드, 설정자, 표기법 등에 묻어버린다(숨긴다?).
- 객체를 할당하고 연결하는 것이 의도를 표현하지 않기 때문에 시스템의 행위를 이해하는 데 도움이 되지 못한다. 
- 코드를 두 가지 계층으로 구성
  - 객체의 그래프에 해당하는 구현 계층 : 객체가 이벤트에 어떻게 반응하는가?
  - 구현계층의 객체를 만들어내는 선언적 계층 : 각 부분의 용도를 기술(하려는 일이 무엇인가?), 좀 더 융통성이 있어 메서드 호출 연쇄(열차 전복), 정적 메서드 사용 가능
  - 이전 절의 예제를 다음과 같이 재작성 할 수 있다.
```java
context.checking(new Expectations() {{
	oneOf(example).doSomething(with(any(String.class)));
}});
```
  - Expectations 객체는 예상 구문을 생성하는 빌더로써 예상 구문과 매처의 조합을 생성해 그것을 Mockery로 불러들이는 메서드가 정의되어 있음
  - 선언적 계층은 거듭되는 '무차별적인' 리팩터링에서 나타난다. 객체를 직접 구성하고 중복을 제거, 도우미 메서드를 추가해 문법적 잡음을 추려내고 예상 구문을 추가, 어떤 영역이 명확해질 때까지 구조를 추가하거나 옮기는 과정에서 발생
![Alt text](https://github.com/betterdevstomorrow/tdd/blob/master/chapter03/image/pig_7_2.PNG)
- 목표는 더 적은 코드로 더 많은 일을 해내는 것(객체가 더 작은 해우이의 단위를 형성하는 수준에 이르도록 구현)

### 7.9 그럼 클래스는?
- 보통 클래스보다 인터페이스를 강조하는데, 다른 객체에서 보는 것은 결국 인터페이스이기 때문이다. 객체의 타입은 해당 객체가 수행하는 역할로 규정된다.
- 클래스는 구현 세부 사항으로 타입을 구현하는 한 방식이지 타입 자체는 아니다.
- 공통적인 행위를 추려냄으로써 클래스 계층 구조를 파악하며 가능하다면 위임(클래스에 포함시킴?)으로 리팩터링 하는 방식을 선호 -> 위임으로 코드를 더 유연하고 이해하기 쉽게 만들 수 있음
- 값 타입은 동위 요소가 없어서 위임을 사용할 가능성이 낮다.



- 첫 출시를 달성하는 데 필요한 주요 시스템 컴포넌트와 그러한 컴포넌트의 상호 작용 방식에 대한 대략적인 그림이 필요하다.
- '동작하는 골격'의 핵심은 팀에서 자신들의 해법을 전체적으로 조망하는 데 이바지하게끔 첫 테스트를 작성하는 과정을 활용해 프로젝트의 맥락을 짚어내는 데 있다.
- 실제 피드백을 토대로 배우고 개선해 나가는 과정을 시작할 수 있게 TDD 주기를 시작하는 데 필요한 최소한의 의사 결정을 내리는 과정이다.

### 4.3 피드백 소스 구축
- 애플리케이션 설계의 옮고 그름에 대해서는 아무것도 보장할 수 없다.
- 현재 밝고 있는 절차에 피드백을 적용해 최대한 빨리 의사 결정이나 가정을 검증하는데 의지할 뿐이다.
- 정기적으로 운영 시스템에 릴리스 하면 시스템의 이해관계자들이 시스템이 요구에 얼마나 부합하는지에 반응할 수 있고, 동시에 우리는 시스템 구현을 평가할 수 있다.
  - 우리는 빌드 및 자동화 테스트를 활용해 시스템 풀질에 관한 피드백을 받는다.
  - 자동화된 배포는 실제 사용자에게 자주 출시하는 데 도움이 된다.
- 테스트를 먼저 작성한다는 것은 철저한 회귀 테스트 모음을 갖게 된다는 것을 의미하며, 견고한 테스트 모음이 있으면 중대한 변경을 안전한게 할 수 있다.

### 4.4 불확실성은 일찍 드러내라
- '동작하는 골격'을 동작하게 하는 데는 시간이 걸린다.
  - 첫 단계에서 상당한 기반 구조를 다지고, 답하기 곤란한 갖가지 질문을 하는 과정을 거치기 때문이다.
  - 처음에는 불안정한 상태로 시작하지만 일부 기능을 구현하고 프로젝트 자동화가 구축되고 나면 반복적인 과정으로 안정화된다.
  - '동작하는 골격'은 프로젝트 초기에 각종 쟁점을 드러낸다.
- 나중에 통합을 절차를 수행하는 방식은 대개 팀에서 처음으로 시스템 통합을 시도하는 프로젝트 후반부에 힘들어지곤 한다.

## 5장. 테스트 주도 개발 주기의 유지
### 5.1 각 기능을 인수 테스트로 시작하라
- 인수 테스트를 작성하는 것으로 신기능을 작업하는 데 착수한다.
  - 인수 테스트는 우리가 작성하려는 기능을 아직 시스템에서 갖추지 못했다는 사실을 보여주고 그 기능이 완성되기까지 진행 상황을 반영한다.
  - 인수 테스트를 작성할 때는 기반 기술(데이터베이스나 웹 서버 같은)의 용어가 아닌 응용 도메인에서 나온 용어만 사용한다.
  - 코딩을 시작하기 전에 테스트를 작성하면 달성하고 하는 바가 명확해진다.
    - 실패하는 테스트 덕에 요구 사항을 충족하는 데 필요한 만큼의 기능만 구현하는데 집중할 수 있다.
    - 테스트로 시작하면 사용자 관점에서 시스템을 바라보게 되어 구현자 관점에서 기능을 짐작하지 않고 사용자가 필요로 하는 것을 이해하게 된다.
- 단위 테스트는 객체나 작은 객체 집합을 격리된 상태에서 시험한다.
  - 단위 테스트는 클래스를 설계와 동작에 확신을 주지만 그 클래스가 시스템의 나머지 부분과 조화롭게 동작할지에 대해서는 담보하지 않는다.
- 인수 테스트는 단위 테스트를 거친 객체를 대상으로 통합 테스트를 수행하며 프로젝트를 앞으로 나아가게 한다.

### 5.2 회귀를 포작하는 테스트와 진행 상황을 측정하는 테스트를 분리하라
- 진행 중인 테스트 그룹:
  - 새 인수 테스트는 진행 중인 작업을 나타내고 기능이 준비될 때까지는 통과하지 않을 것이다.
  
- 회귀 테스트 그룹:
  - 완성된 기능에 대한 인수 테스트는 실행하는 데 시간이 오래 걸려도 회귀를 포착하고 늘 통과해야 한다.
  - 요구 사항이 바뀌면 거기에 영향을 받은 인수 테스트를 회귀 테스트 그룹에서 빼내서 진행 중인 테스트 그룹으로 옮긴 후 새 요구 사항을 반영토록 한다.

### 5.3 테스트를 가장 간단한 성공 케이스로 시작하라
- 새 클래스나 기능을 만들어야 할 때 어디서 출발해야 할까?
  - 상투적인 케이스는 충분한 피드백을 전해주지 않는다.
  - 가장 간단한 성공 케이스로 시작한다.
    - 해당 테스트가 동작하면 솔루션의 실제 구조에 관해 더 좋은 생각이 떠오를 테고, 그 과정에서 발견한 발생 가능한 실패를 처리하는 것과 이후의 성공 케이스 사이에서 우선순위를 가늠해 볼 수 있다.

### 5.4 읽고 싶어 할 테스트를 작성하라
- 각 테스트를 시스템이나 객체에서 수행할 행위로 가능한 명확하게 표한한다.
- 테스트가 잘 읽히면 테스트를 그 다음으로 지원하는 기반 구조를 만든다.
  - 테스트가 어떻게 해야 할지 기술하는 명확한 오류 메시지를 보이면서 예상대로 실패하면 보조적인 역할을 하는 코드를 충분히 구현했다는 사실을 알게 된다.

### 5.5 테스트가 실패하는 것을 지켜보라
- 테스트를 통과하는 코드를 작성하기 전에 테스트가 실패하는 것을 지켜본 후 진단 메시지를 확인한다.
- 오류 메시지가 코드와 관련된 문제로 우리를 이끌 때까지 테스트 코드를 조정하고 테스트를 재실행한다.
- 오류 메시지를 검사해야 하는 이유:
  - 오류 메시지는 현재 작업 중인 코드에 대한 가정을 확인한다.
  - 의도에 대한 표현을 강조하는 것은 신뢰성 있고 유지하기 쉬운 시스템을 개발하는 데 필수고, 테스트와 실패 메시지가 여기에 해당한다.
  - 유용한 진단 정보를 생성하는 과정에서 테스트, 코드에서 해야 할 일이 뭔지 분명하게 하는 데 도움이 된다.

### 5.6 입력에서 출력 순서로 개발하라
- 외부 이벤트를 받는 객체에서 중간 계츨을 거쳐 중심 도메인 모델로 나아간 다음, 외부에서 확인 가능한 응답을 생성하는, 다른 경계에 위치한 객체에까지 이른다.
- 잘못된 방법: 
  - 새 도메인 모델 객체에 단위 테스트를 수행한 다음 애플리케이션의 나머지 부분에 해당 객체를 끼워 넣는 식으로 시작하는 방법.
    - 나중에 통합 문제를 일으킬 가능성이 크다.
    - 도메인 모델을 작업할 때 올바른 피드백을 받지 못했기 때문에 불필요하거나 올바르지 않은 기능을 구현할 가능성이 크다.

### 5.7 메서드가 아닌 행위를 단위 테스트하라
- 흔히 저지르는 실수는 메서드 테스트를 생각한다는 데 있다.
  - 메서드 테스트는 그것이 뭘 하는지 말해주지만 목적이 뭔지 알려주지 않는다.
- 테스트 대상 객체에서 제공해야 하는 기능에 집중한다.
  - 해당 클래스의 모든 실행 결로(메서드)를 시험하는 방식이 아니라 그 클래스로 목표를 달성하는 방법을 알아야 한다.
  - 테스트 이름을 지을 때는 테스트 중인 시나리오에서 객체가 어떻게 동작하는지 설명하는 이름을 선택한다.

### 5.8 테스트에 귀를 기울이라
- 테스트하기 어려운 코드는 주로 설계 개선이 필요하다.
- 실패할 테스트를 작성하기 어렵다면 제품 코드의 설계를 다시 살펴보고 앞으로 나가아기 전에 리팩터링한다.
- 설계에 취약함이 보일 때 리팩터링을 통해 시스템 품질을 유지한다면 어떠한 변화가 일어나도 거기에 대응할 수 있을 것이다.

### 5.9 주기의 미세 조정
- 단위 테스트를 얼마나 해야 하고 통합 테스트는 얼마나 해야 하는가?
  - 로직에서 성가신 부분에는 단위 테스트(아니면 단순화)가 더 필요할 수도 있다.
  - 처리하지 않은 예외에는 통합 수준의 테스트가 더 필요할지도 모른다.
  - 예상치 못한 시스템 실패에는 조사가 더 필요하거나 어쩌면 테스트를 더 철저하게 해야 할 것이다.
