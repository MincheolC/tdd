## 7장 객체 지향 설계의 달성
### 7.1 테스트를 먼저 작성하는 것이 설계에 어떻게 도움이 되는가
- 호출자는 객체가 무슨 일을 하고 무엇에 의존하는지 알고 싶을 뿐, 객체가 어떻게 동작하는지는 알고 싶어 하지 않음
- 객체가 해당 객체를 둘러싼 더 큰 환경과 조화되는 응집력 있는 단위를 나타내기를 바람
- 위와 같은 목적에 도움이 되는 TDD의 세 가지 측면
  #### 1 '어떻게'를 고려하기 전에 달성하는 바가 '무엇인지'를 기술해야 함
  - 대상 객체에 대한 추상화를 올바른 수준으로 유지
  - 단위 테스트의 의도가 불분명하다면 개념이 뒤죽박죽이 될 것임
  - 객체 외부에서 무엇을 볼 수 있는지 결정해야 하므로 정보 은닉에도 도움이 됨
  #### 2 단위 테스트의 범위를 제한해야 함
  - 단위 테스트가 수십줄이 되어 테스트의 요점이 묻히는 경우가 발생
  - 컴포넌트를 최대한 쪼개어 단순한 테스트로 작성
  #### 3 해당 객체의 의존성을 전달하기 위해 의존성이 어디에 있는지 알아야 함
  - 의존성을 정리하여 콘텍스트 단위 테스트를 위한 객체들의 독립성을 높여야 함

### 7.2 분류보다 의사소통
- 인터페이스는 두 컴포넌트가 잘 맞는지를 기술하는 반면, 프로토콜은 두 컴포넌트가 함께 동작하는지를 기술
- 잘 설계된 클래스 구조를 달성하는 것보다 객체의 의사소통 패턴이 더 중요
- 목 객체를 활용한 TDD는 개발 과정에서 통신 프로토콜을 발견하는 수단이자 코드의 설명으로 작용

```java
@Test public void
notifiesAuctionClosedWhenCloseMessageReceived() {
	Message message = new Message();
	message.setBody("SOLVersion: 1.1; Event: CLOSE;");
	
	context.checking(new Expectations() {{
		oneOf(listener).auctionClosed();
	}});
	
	translator.processMessage(UNUSED_CHAT, message);
}
```
- listener 인터페이스에 다른 메서드도 있지만, 위 테스트는 해당 프로토콜에서 auctionClosed() 메서드가 딱 한 번만 호출되어야 함을 말해준다.
- 목 객체는 객체 내부에 존재하는 것이 아니라 객체와 동위 요소(해당 객체의 의존성, 알림, 조정을 대상으로)로 만들어야 함
- 한 객체의 인접 요소를 강조하는 테스트는 그것들이 이웃 요소인지, 대상 객체의 내부를 구성해야 하는지 파악하는 데 기여
- 불분명한 테스트는 구현 세부 사항을 너무 드러냄

### 7.3 값 타입
- 값은 불변이라서 좀 더 단순하고 유의미한 식별자가 없으며, 객체에는 상태가 있어서 식별자가 있고 서로 관계를 맺는다.
- 시스템에 String을 사용하기보다 Item 타입을 만들면 메서드 호출없이 변경과관련된 코드를 찾아낼 수 있다.
- 구체적인 타입은 혼동의 위험을 줄임(화성 기후 탐사선의 미터, 피트의 경우와 같이)
- 개념을 표현하는 타입을 만들어두면 행위를 추가하기에 적절함(코드 구석구석에 흩어놓는 대신 좀 더 객체지향적)
- 값 타입을 위한 세 가지 기법
  #### 1 분해(breaking out)
  - 객체의 코드가 복잡해지고 있다면 응집력 있는 행위의 단위로 분해
  - 메시지 문자열을 구문 분석, 구문 분석 결과를 해석하는 단위로 분해
  #### 2 파생(budding off)
  - 새로운 도매인 개념을 표시하고 싶을 때 필드 하나만 있거나 필드가 아무것도 없는 위치지정자 타입을 도입
  - 코드 규모가 커짐에 따라 필드와 메서드를 추가해 새로운 타입의 세부 사항을 채우고 각 타입을 통해 추상화 수준을 높임
  #### 3 포장(bundling up)
  - 어떤 값들이 함께 사용된다는 사실을 알게될 경우 함께 취급되는 공용 필드가 포함된 타입을 새로 만듦
  - 새 타입으로 행위를 옮길 수 있는데 이는 인터페이스 너머로 새 타입에 포함된 필드를 감추어 '전체는 부분의 합보다 단순해야 한다'를 만족함

### 7.4 객체는 어디에서 오는가?
- 객체 타입을 발견하는 범주는 대개 다들 비슷하다.
#### 7.4.1 분해: 큰 객체를 협력 객체의 그룹으로 나누기
- 작성한 코드가 복잡해질 경우 응집력 있는 기능 단위를 좀 더 작은 협력 객체로 만드는 작업을 할 수 있다.
- 손쉽게 테스트할 수 없을 정도로 크거나 테스트 실패 이유를 해석하기 어려우면 해당 객체를 분해하여 단위 테스트를 수행
#### 7.4.2 파생: 객체가 필요로 하는 신규 서비스 정의와 해당 서비스를 제공하기 위한 새 객체 추가
- 어떤 객체를 구현할 때 그 객체가 또 다른 객체에서 제공받아야 할 서비스를 필요로 한다는 사실을 발견
- 새로운 서비스에 이름을 부여하고 클라이언트 객체와 새로운 서비스 간 관계를 명확히 하고자 해당 서비스를 클라이언트 객체의 단위 테스트 바깥에서 목 객체로 만들어 제공
- 서비스를 제공하는 객체 작성(객체가 필요로하는 서비스가 뭔지 파악)?? => 서비스를 제공하는 또 다른 객체 작성(기존 객체가 필요로 하는 서비스가 무엇인지 파악)
- 기존 객체, 또는 자체적으로 만든 API나 서드파티 API와 연결하기 전까지 협력 객체의 관계로 구성된 흐름을 가짐
#### 7.4.3 포장: 관련 객체를 포함 객체로 감추기
- 함께 동작하는 관련 객체의 집합이 있을 경우 그것들을 하나로 포함하는 객체로 포장할 수 있다.(좀 더 높은 추상화 수준을 가짐)
- 암시적인 개념을 구체적으로 만드는 과정의 장점
  - 도메인을 좀 더 잘 이해하는 데 보탬이 되는 이름을 부여해야 함
  - 개념의 경계를 확인할 수 있으므로 의존성의 범위를 좀 더 명확하게 한정할 수 있다.
  - 단위 테스트를 좀 더 정확하게 수행할 수 있다.(새로운 구성 객체를 직접 테스트, 뽑아낸 객체의 코드에 대한 테스트를 위해 목 구현체 사용 가능)
### 7.5 인터페이스로 관계를 식별하라
- 인터페이스를 사용해 객체가 수행할 수 있는 역할에 이름을 부여하고 객체가 받아들일 메시지를 기술
- 인터페이스를 되도록 한정된 범위로 사용하려 한다. 인터페이스에 선언되는 메서드 수가 적을수록 해당 메서들르 호출하는 객체의 역할이 명확해진다.
- 클라이언트에 코드에서 인터페이스를 쓰면 불필요한 정보가 새는 현상을 방지하여 객체 간의 암시적인 결합이 최소화되고 변경하기 쉬운 코드가 된다.
### 7.6 인터페이스도 리팩터링하라
- 공통적인 역할을 뽑아내면 '착탈 가능한' 컴포넌트가 많아져서 설계가 좀 더 높은 수준의 추상화로 작업할 수 있다.
- 개념을 이해하는 데 걸리는 시간이 더 적어질 수 있다.
- 구현하는 클래스의 구조가 불분명하다는 사실을 알게된다면 인터페이스가 너무 장황해서 쪼개야한다는 힌트가 된다.
### 7.7 객체를 구성해 시스템의 행위를 기술하라
- 단위 수준의 TDD는 시스템을 값 타입과 느슨하게 결합된 계산 관련 객체로 분해하는 데 길잡이 노릇을 함
- jMock에서는 테스트를 위해 예상 호출을 기술한 내용을 Mockery 콘텍스트 객체 내에서 조합 -> 테스트가 실행되는 동안 Mockery는 목 객체의 대상 객체를 상대로 발생한 호출을 Expectation에 전달 -> 각 Expectation에서 호출 일치 여부 검사 -> 일치하면 테스트 성공, 불일치하면 테스트 실패
- 비교적 적은 코드로 유연한 애플리케이션 구조가 만들어지며, 여러 관련 시나리오를 지원해야 할 때 적절한 방법
- 각 시나리오에 대해 구축할 다양한 컴포넌트 조합은 애플리케이션의 어떤 부분에 들어갈 하위 시스템에 해당함
- 설계 확장이 쉽다.
![Alt text](https://github.com/betterdevstomorrow/tdd/blob/master/chapter02/image/pig_7_1.PNG)

- example.doSomething() 메서드가 String 타입의 인자로 정확히 한 번 호출되는지 확인하는 테스트 코드는 다음과 같다.
```java
InvocationExpectation expectation = new InvocationExpectation();
expectation.setParametersMatcher(new AllParametersMatcher(Arrays.asList(new IsInstanceOf(String.class))));
expectation.setCardinality(new Cardinality(1, 1));
expectation.setMethodMatcher(new Method(NameMatcher("doSomething"));
expectation.setObjectMatcher(new IsSame<Example>(example));

context.addExpectation(expectation);
```

### 7.8 고수준 프로그래밍을 위한 대비
- 우리는 흔히 객체와 그것들의 관계에 관한 정보를 키워드, 설정자, 표기법 등에 묻어버린다(숨긴다?).
- 객체를 할당하고 연결하는 것이 의도를 표현하지 않기 때문에 시스템의 행위를 이해하는 데 도움이 되지 못한다. 
- 코드를 두 가지 계층으로 구성
  - 객체의 그래프에 해당하는 구현 계층 : 객체가 이벤트에 어떻게 반응하는가?
  - 구현계층의 객체를 만들어내는 선언적 계층 : 각 부분의 용도를 기술(하려는 일이 무엇인가?), 좀 더 융통성이 있어 메서드 호출 연쇄(열차 전복), 정적 메서드 사용 가능
  - 이전 절의 예제를 다음과 같이 재작성 할 수 있다.
```java
context.checking(new Expectations() {{
	oneOf(example).doSomething(with(any(String.class)));
}});
```
  - Expectations 객체는 예상 구문을 생성하는 빌더로써 예상 구문과 매처의 조합을 생성해 그것을 Mockery로 불러들이는 메서드가 정의되어 있음
  - 선언적 계층은 거듭되는 '무차별적인' 리팩터링에서 나타난다. 객체를 직접 구성하고 중복을 제거, 도우미 메서드를 추가해 문법적 잡음을 추려내고 예상 구문을 추가, 어떤 영역이 명확해질 때까지 구조를 추가하거나 옮기는 과정에서 발생
![Alt text](https://github.com/betterdevstomorrow/tdd/blob/master/chapter02/image/pig_7_2.PNG)

- 목표는 더 적은 코드로 더 많은 일을 해내는 것(객체가 더 작은 해우이의 단위를 형성하는 수준에 이르도록 구현)

### 7.9 그럼 클래스는?
- 보통 클래스보다 인터페이스를 강조하는데, 다른 객체에서 보는 것은 결국 인터페이스이기 때문이다. 객체의 타입은 해당 객체가 수행하는 역할로 규정된다.
- 클래스는 구현 세부 사항으로 타입을 구현하는 한 방식이지 타입 자체는 아니다.
- 공통적인 행위를 추려냄으로써 클래스 계층 구조를 파악하며 가능하다면 위임(클래스에 포함시킴?)으로 리팩터링 하는 방식을 선호 -> 위임으로 코드를 더 유연하고 이해하기 쉽게 만들 수 있음
- 값 타입은 동위 요소가 없어서 위임을 사용할 가능성이 낮다.
