# 2부. 테스트 주도 개발 과정

## 4장. 테스트 주도 주기 시작
### 4.1 우선 동작하는 골격을 대상으로 테스트하라
- 첫 인수 테스트를 작성하고 통과하는 일의 어려움은, 도구를 마련하고 동시에 도구로 테스트를 하면서 기능까지 구현하기가 어렵다는 데 있다.
- 이를 두 문제로 쪼개서 해결하면,
  - '동작하는 골격'을 대상으로 빌드/배포/테스트하는 방법을 파악한 다음
  - 그 기반 구조를 이용해 유의미한 첫 기능에 대한 인수 테스트를 작성한다.
- '동작하는 골격'이란 전 구간을 대상으로 자동 빌드/배포/테스트 할 수 있는 실제 기능을 가장 얇게 구현한 조각을 말한다.
  - Ex) 데이터베이스를 활용하는 웹 애플리케이션이라면 골격에서는 데이터베이스 필드가 포함된 웹 페이지를 보여줄 것이다.
  - '동작하는 골격'을 만드는 동안에는 골격의 구조에 집중하고, 테스트가 최대한 표현력을 갖추게끔 테스트를 정리하는 일에 대해서는 크게 신경쓰지 않는다.

### 4.2 동작하는 골격의 외형 결정
![Alt text](https://github.com/Hyunhoo-Kwon/tdd/blob/master/chapter02/images/%EC%9A%94%EA%B5%AC%20%EC%82%AC%ED%95%AD%20%ED%94%BC%EB%93%9C%EB%B0%B1.jpeg)
- 첫 출시를 달성하는 데 필요한 주요 시스템 컴포넌트와 그러한 컴포넌트의 상호 작용 방식에 대한 대략적인 그림이 필요하다.
- '동작하는 골격'의 핵심은 팀에서 자신들의 해법을 전체적으로 조망하는 데 이바지하게끔 첫 테스트를 작성하는 과정을 활용해 프로젝트의 맥락을 짚어내는 데 있다.
- 실제 피드백을 토대로 배우고 개선해 나가는 과정을 시작할 수 있게 TDD 주기를 시작하는 데 필요한 최소한의 의사 결정을 내리는 과정이다.

### 4.3 피드백 소스 구축
- 애플리케이션 설계의 옮고 그름에 대해서는 아무것도 보장할 수 없다.
- 현재 밝고 있는 절차에 피드백을 적용해 최대한 빨리 의사 결정이나 가정을 검증하는데 의지할 뿐이다.
- 정기적으로 운영 시스템에 릴리스 하면 시스템의 이해관계자들이 시스템이 요구에 얼마나 부합하는지에 반응할 수 있고, 동시에 우리는 시스템 구현을 평가할 수 있다.
  - 우리는 빌드 및 자동화 테스트를 활용해 시스템 풀질에 관한 피드백을 받는다.
  - 자동화된 배포는 실제 사용자에게 자주 출시하는 데 도움이 된다.
- 테스트를 먼저 작성한다는 것은 철저한 회귀 테스트 모음을 갖게 된다는 것을 의미하며, 견고한 테스트 모음이 있으면 중대한 변경을 안전한게 할 수 있다.

### 4.4 불확실성은 일찍 드러내라
- '동작하는 골격'을 동작하게 하는 데는 시간이 걸린다.
  - 첫 단계에서 상당한 기반 구조를 다지고, 답하기 곤란한 갖가지 질문을 하는 과정을 거치기 때문이다.
  - 처음에는 불안정한 상태로 시작하지만 일부 기능을 구현하고 프로젝트 자동화가 구축되고 나면 반복적인 과정으로 안정화된다.
  - '동작하는 골격'은 프로젝트 초기에 각종 쟁점을 드러낸다.
- 나중에 통합을 절차를 수행하는 방식은 대개 팀에서 처음으로 시스템 통합을 시도하는 프로젝트 후반부에 힘들어지곤 한다.

## 5장. 테스트 주도 개발 주기의 유지
### 5.1 각 기능을 인수 테스트로 시작하라
- 인수 테스트를 작성하는 것으로 신기능을 작업하는 데 착수한다.
  - 인수 테스트는 우리가 작성하려는 기능을 아직 시스템에서 갖추지 못했다는 사실을 보여주고 그 기능이 완성되기까지 진행 상황을 반영한다.
  - 인수 테스트를 작성할 때는 기반 기술(데이터베이스나 웹 서버 같은)의 용어가 아닌 응용 도메인에서 나온 용어만 사용한다.
  - 코딩을 시작하기 전에 테스트를 작성하면 달성하고 하는 바가 명확해진다.
    - 실패하는 테스트 덕에 요구 사항을 충족하는 데 필요한 만큼의 기능만 구현하는데 집중할 수 있다.
    - 테스트로 시작하면 사용자 관점에서 시스템을 바라보게 되어 구현자 관점에서 기능을 짐작하지 않고 사용자가 필요로 하는 것을 이해하게 된다.
- 단위 테스트는 객체나 작은 객체 집합을 격리된 상태에서 시험한다.
  - 단위 테스트는 클래스를 설계와 동작에 확신을 주지만 그 클래스가 시스템의 나머지 부분과 조화롭게 동작할지에 대해서는 담보하지 않는다.
- 인수 테스트는 단위 테스트를 거친 객체를 대상으로 통합 테스트를 수행하며 프로젝트를 앞으로 나아가게 한다.

### 5.2 회귀를 포작하는 테스트와 진행 상황을 측정하는 테스트를 분리하라
- 진행 중인 테스트 그룹:
  - 새 인수 테스트는 진행 중인 작업을 나타내고 기능이 준비될 때까지는 통과하지 않을 것이다.
  
- 회귀 테스트 그룹:
  - 완성된 기능에 대한 인수 테스트는 실행하는 데 시간이 오래 걸려도 회귀를 포착하고 늘 통과해야 한다.
  - 요구 사항이 바뀌면 거기에 영향을 받은 인수 테스트를 회귀 테스트 그룹에서 빼내서 진행 중인 테스트 그룹으로 옮긴 후 새 요구 사항을 반영토록 한다.

### 5.3 테스트를 가장 간단한 성공 케이스로 시작하라
- 새 클래스나 기능을 만들어야 할 때 어디서 출발해야 할까?
  - 상투적인 케이스는 충분한 피드백을 전해주지 않는다.
  - 가장 간단한 성공 케이스로 시작한다.
    - 해당 테스트가 동작하면 솔루션의 실제 구조에 관해 더 좋은 생각이 떠오를 테고, 그 과정에서 발견한 발생 가능한 실패를 처리하는 것과 이후의 성공 케이스 사이에서 우선순위를 가늠해 볼 수 있다.

### 5.4 읽고 싶어 할 테스트를 작성하라
- 각 테스트를 시스템이나 객체에서 수행할 행위로 가능한 명확하게 표한한다.
- 테스트가 잘 읽히면 테스트를 그 다음으로 지원하는 기반 구조를 만든다.
  - 테스트가 어떻게 해야 할지 기술하는 명확한 오류 메시지를 보이면서 예상대로 실패하면 보조적인 역할을 하는 코드를 충분히 구현했다는 사실을 알게 된다.

### 5.5 테스트가 실패하는 것을 지켜보라
- 테스트를 통과하는 코드를 작성하기 전에 테스트가 실패하는 것을 지켜본 후 진단 메시지를 확인한다.
- 오류 메시지가 코드와 관련된 문제로 우리를 이끌 때까지 테스트 코드를 조정하고 테스트를 재실행한다.
- 오류 메시지를 검사해야 하는 이유:
  - 오류 메시지는 현재 작업 중인 코드에 대한 가정을 확인한다.
  - 의도에 대한 표현을 강조하는 것은 신뢰성 있고 유지하기 쉬운 시스템을 개발하는 데 필수고, 테스트와 실패 메시지가 여기에 해당한다.
  - 유용한 진단 정보를 생성하는 과정에서 테스트, 코드에서 해야 할 일이 뭔지 분명하게 하는 데 도움이 된다.

### 5.6 입력에서 출력 순서로 개발하라
- 외부 이벤트를 받는 객체에서 중간 계츨을 거쳐 중심 도메인 모델로 나아간 다음, 외부에서 확인 가능한 응답을 생성하는, 다른 경계에 위치한 객체에까지 이른다.
- 잘못된 방법: 
  - 새 도메인 모델 객체에 단위 테스트를 수행한 다음 애플리케이션의 나머지 부분에 해당 객체를 끼워 넣는 식으로 시작하는 방법.
    - 나중에 통합 문제를 일으킬 가능성이 크다.
    - 도메인 모델을 작업할 때 올바른 피드백을 받지 못했기 때문에 불필요하거나 올바르지 않은 기능을 구현할 가능성이 크다.

### 5.7 메서드가 아닌 행위를 단위 테스트하라
- 흔히 저지르는 실수는 메서드 테스트를 생각한다는 데 있다.
  - 메서드 테스트는 그것이 뭘 하는지 말해주지만 목적이 뭔지 알려주지 않는다.
- 테스트 대상 객체에서 제공해야 하는 기능에 집중한다.
  - 해당 클래스의 모든 실행 결로(메서드)를 시험하는 방식이 아니라 그 클래스로 목표를 달성하는 방법을 알아야 한다.
  - 테스트 이름을 지을 때는 테스트 중인 시나리오에서 객체가 어떻게 동작하는지 설명하는 이름을 선택한다.

### 5.8 테스트에 귀를 기울이라
- 테스트하기 어려운 코드는 주로 설계 개선이 필요하다.
- 실패할 테스트를 작성하기 어렵다면 제품 코드의 설계를 다시 살펴보고 앞으로 나가아기 전에 리팩터링한다.
- 설계에 취약함이 보일 때 리팩터링을 통해 시스템 품질을 유지한다면 어떠한 변화가 일어나도 거기에 대응할 수 있을 것이다.

### 5.9 주기의 미세 조정
- 단위 테스트를 얼마나 해야 하고 통합 테스트는 얼마나 해야 하는가?
  - 로직에서 성가신 부분에는 단위 테스트(아니면 단순화)가 더 필요할 수도 있다.
  - 처리하지 않은 예외에는 통합 수준의 테스트가 더 필요할지도 모른다.
  - 예상치 못한 시스템 실패에는 조사가 더 필요하거나 어쩌면 테스트를 더 철저하게 해야 할 것이다.
