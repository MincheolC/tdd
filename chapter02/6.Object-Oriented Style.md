## 6장. 객체 지향 스타일
### 6.1 유지 보수성을 고려한 설계
- 코드 규모가 커질수록 유지보수가 쉬워지려면, 기능->객체->패키지->프로그램->시스템 순으로 구조화
- 구조화를 위한 두 가지 휴리스틱
  #### 1 관심사의 분리
  - 동작 방식 변경을 위해 최대한 적은 양의 코드를 수정하는 것이 좋다
  - 같은 이유로 변경해야 할 코드는 한데 모은다. (메세지를 푸는 코드와 해석하는 코드를 분리)
  #### 2 더 높은 수준의 추상화
  - 더 높은 수준의 추상화(복잡한 개념에서 기능을 간추려 냄)를 활용해 복잡성을 피함
  - 변수, 제어를 조작하기 보단 유용한 기능 컴포넌트를 조합하여 작성
  - 포트와 어댑터 아키텍처
    - 포트 : 애플리케이션 용어로 외부 객체를 표현하는 인터페이스 작성(기술적 개념 제외)
	- 어댑터 : 애플리케이션의 핵심부와 각 기술 도메인 사이에 브리지 코드 작성
![Alt text](https://github.com/betterdevstomorrow/tdd/blob/master/chapter02/image/pig_6_1.PNG)

  * 캡슐화와 정보 은닉
    - 캡슐화 : 객체의 행위가 해당 객체의 API를 통해서만 좌우될 수 있음을 보장(관련 없는 컴포넌트 간 의존성 제거)
	- 정보 은닉 : 객체가 해당 객체의 기능을 구현하는 방법을 API단으로 숨김
	
### 6.2 내부 대 이웃
- 시스템 구성 시 해당 객체가 명확한 API와 함께 응집력 있는 추상화를 제공하도록 해야함
- 내부에 접근하는 것을 API를 통해 캡슐화, 나머지 시스템으로부터 세부 사항 은닉
- 이웃(peer) : 한 객체와 의사소통하는 객체

```java
(EditSaveCustomizer) master.getModelisable()
	.getDockablePanel()
	.getCustomizer()
	.getSaveItem.setEnabled(Boolean.FALSE.booleanValue());
```
- 캡슐화, 은닉 정도는 어떤 객체를 얼마나 쉽게 쓸 수 있는지에 영향을 줘 시스템 내부 품질에 기여
- 낮은 추상화는 열차 전복 코드처럼 유지 보수 비용이 증가(master 변경을 위해 모든 중간 관계를 변경해야 함)	

### 6.3 단일 책임 원칙
- 모든 객체는 반드시 단 한 가지 명확히 규정된 책임을 지녀야 함
- 객체의 역할을 설명할 때 접속사 없이 설명할 수 있어야 함(접속사가 들어가면 각 절마다 객체가 됨)
- 여러 객체를 조합해 새로운 추상화를 만들 때도 적용(전체는 부분의 합보다 단순해야 함)

### 6.4 객체 이웃의 유형
- 객체가 지닐 수 있는 관계 3가지
  #### 1 의존성
  - 한 객체가 자신의 역할을 수행할 수 있게 이웃하는 객체에게 요구하는 서비스
  - 이웃의 서비스 없이는 기능을 수행하지 못함
  #### 2 알림
  - 한 객체의 최근 활동을 지속적으로 파악하는 이웃
  - 상태가 바뀌거나 중요한 활동을 수행할 때마다 특정 이웃에게 알림
  - 비유도형 미사일과 같이 어떤 이웃이 listener로 등록되어 있는지 신경쓰지 않음
  - 객체를 서로 분리해줌(인터페이스가가 모든 등록된 리스너에게 알리지만 리스너가 무엇을 했는지 알지 못하고, 리스너도 인터페이스로부터 호출될 것은 알지만 인터페이스가 어떻게 이벤트를 전달할지는 알지 못함)
  #### 3 조정
  - 객체 행위를 더 넓은 시스템의 요건에 맞게 조정하는 이웃
  - 해당 객체를 대신해 의사 결정을 내리는 정책 객체, 복합체인 경우 해당 객체의 컴포넌트를 포함
    - JTable의 TableCellRenderer에서 색상 값으로 RGB를 사용한다면, 렌더러(renderer)를 변경함으로써ㅓ HSB(색조,채도,명도) 값으로 표현될 수 있음

- 유효한 객체를 만들기 위해 노력하지만, 의존성의 경우 요구된 서비스를 이용할 수 있기 전까지는 객체를 생성하더라도 NullPointerException을 발생시킬 것이다.(강제 할당 방법이 있긴 함)
- 조정의 경우 공통 값으로, 알림의 경우 널 객체나 빈 컬렉션으로 초기화 하고 메서드를 추가해 호출하는 쪽에서 값을 변경하도록 할 수 있음.

### 6.5 전체는 부분의 합보다 단순해야 한다
- 객체를 조합해 새 타입을 만들 때 새 타입이 그것을 구성하는 모든 구성 요소를 합한 것보다 단순한 행위를 보여주게 하고 싶음
- 복합 객체의 API는 반드시 구성 요소의 존재와 구성 요소 간 상호 작용을 감추고 더 단순한 추상화를 보여주어야 함
- 시계에서 시간을 표시하는 두세 개의 침, 태엽 감는 꼭지 등이 있지만 모두 한데 조립되어 있음
- 금액 값을 수정하기 위해 금액 수정, 통화 수정 컴포넌트로 구성될 수 있다. 컴포넌트의 API에서 두 값을 모두 처리하지 못한다면, 다음과 같이 컴포넌트를 직접 제어할 수밖에 없을 것이다.
```java
moneyEditor.getAmountField().setText(String.valueOf(money.amount());
moneyEditor.getCurrencyField().setText(String.valueOf(money.currencyCode());
```
- 다음과 같이 설정자 메서드로 대체하여 추상화 할 수 있다.
```java
moneyEditor.setAmountField(money.amount());
moneyEditor.setCurrencyField(money.currencyCode());
```
- 내부 구조를 제거하고 다음과 같이 나타낼 수 있다.
```java
moneyEditor.setValue(money);
```
### 6.6 콘텍스트 독립성
- 한 객체가 정보를 감췄는지 판단하는 것이 6.5의 내용이었다면, 콘텍스트 독립성은 한 객체가 정보를 너무 많이 감췄거나 잘못된 정보를 감췄는지 판단하는데 유용함
- 각 객체가 해당 객체를 실행하는 시스템에 관해 아무것도 알지 못함
- 어떤 객체가 실행되고 있는, 규모가 더 큰 환경에 대해 해당 객체가 알아야 할 사항을 전부 전달해야 함(생성자에 전달(영구적) 또는 메서드에 전달(일시적))
- 객체의 관계를 명시적으로 만들고 객체 자체와는 별도로 정의되게 만듦
- 다양한 콘텍스트에 적용할 수 있는 응집력 있는 객체를 만들 수 있고, 구성 방법 재설정을 통해 변경 가능한 시스템이 될 수 있음	

### 6.7 올바른 정보 감추기
- 설계 시 아래와 같은 두 개념의 차이점을 인식해야 함
  - 캐시에 대한 자료 구조를 CachingAuctionLoader 클래스에 캡슐화한다(감춘다).
  - 애플리케이션 로그 파일의 이름을 PricingPolicy 클래스에 캡슐화한다(감춘다).
- 로그 파일의 이름을 PricingPolicy에 감추는 업무는 없다(필요하지 않다). 로그 파일의 이름은 외부 환경 설정 수준에 포함되어야 한다.
